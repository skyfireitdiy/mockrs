# `mockrs` — 超越 Trait 的自由函数模拟与线程安全

---

## 1. 背景（用户痛点）：突破 Rust 传统模拟的局限

在 Rust 的生态系统中，测试是构建可靠软件的基石。为此，社区开发了许多优秀的模拟（Mocking）库，例如 `mockall`。这些库功能强大，遵循 Rust 的设计哲学，但它们几乎无一例外地**基于 Trait（接口）进行工作**。开发者需要先定义一个
Trait，然后为这个 Trait 生成一个模拟实现，并通过依赖注入在测试时使用这个模拟版本。

这种模式在设计良好的应用程序中非常有效，因为它鼓励了面向接口编程。然而，它也带来了无法回避的局限性：

*   **无法模拟自由函数**：如果你想模拟一个独立的、不属于任何 Trait 的函数（即自由函数，`fn my_func(...)`），传统模拟库无能为力。
*   **无法模拟外部依赖的具体实现**：当你的代码依赖于一个第三方库的某个具体结构体的方法，而这个方法没有通过 Trait 暴露时，你无法对其进行模拟。
*   **重构成本高**：为了测试一个简单的函数，你可能需要将其重构为 Trait 的一部分，这增加了不必要的代码复杂性和设计约束。
*   **对 FFI 函数束手无策**：当需要模拟与 C/C++ 库交互的 FFI (Foreign Function Interface) 函数时，基于 Trait 的方法完全不适用。

**`mockrs` 的诞生，正是为了解决这一核心痛点**。它提供了一种全新的思路：与其在编译时通过类型系统进行替换，不如在运行时直接深入底层，通过修改函数在内存中的机器码来实现拦截和替换。这使得 `mockrs`
能够**模拟任何函数**，无论是自由函数、具体方法还是 FFI 函数，彻底摆脱了对 Trait 的依赖。

---

## 2. 需求挖掘（项目目标）

*   **任意函数模拟**：在运行时替换**任何**函数，不受 Trait 限制。
*   **绝对的线程安全**：模拟操作应仅限于当前线程，不干扰其他线程的正常执行。
*   **易用性**：提供简洁的 `mock!` 宏，屏蔽底层复杂性。
*   **跨架构支持**：支持 `x86_64` 和 `aarch64` 架构。
*   **RAII 设计**：利用 Rust 的 RAII 特性，在模拟对象生命周期结束时自动恢复原始函数。

---

## 3. 实现难点（技术挑战）

实现 `mockrs` 的功能涉及多个底层技术挑战：

*   **内存操作与权限管理**：安全地修改只读代码段的内存权限。
*   **指令替换与蹦床（Trampoline）**：在函数开头插入陷阱指令，并备份原始指令。
*   **PC 相对寻址指令的重定位**：在指令被移动后，修正其失效的相对地址。
*   **信号处理与上下文切换**：编写安全、精确的信号处理器，不仅要重定向执行流，还要能精细地控制 **CPU 的调试状态**。
*   **线程隔离**：在全局修改的基础上，实现线程特有的行为，这是最精妙的挑战之一。

---

## 4. 解决方案：基于运行时挂钩的动态模拟

`mockrs` 的解决方案与传统模拟库截然不同，它优雅地结合了底层系统编程和 Rust 的高级特性。

### 核心优势：运行时挂钩 (Runtime Hooking)
`mockrs` 不在编译期做任何事情，而是在程序**运行时**通过向目标函数的起始地址写入一条陷阱指令，来“劫持”所有对该函数的调用。这种方法使其能够平等地对待所有函数。

### 核心亮点：真正的线程隔离机制

**挑战**：函数代码位于内存中的一个**全局共享**位置。当 `mockrs` 修改它时，这个变动对所有线程都是可见的。那么，一个全局的修改如何能实现线程级别的行为隔离呢？

**解决方案：“全局提问”与“线程本地回答”的精妙设计**

`mockrs` 将这个问题分解为两部分：

1.  **全局提问（陷阱指令 + 全局信号处理器）**：
    写入函数头部的陷阱指令（如 `int3`）本身不包含任何逻辑。它更像一个全局的“暂停按钮”。一旦任何线程执行到它，就会立刻暂停，并向系统发出一个 `SIGTRAP`
信号，仿佛在问：“执行在这里中断了，接下来该做什么？”。这个问题由一个**全局唯一**的信号处理器来捕获。

2.  **线程本地回答（`thread_local!` 宏）**：
    这个问题的“答案”存放在一个使用 Rust 的 `thread_local!` 宏声明的特殊变量中：
    ```rust
    thread_local! {
        static G_THREAD_REPLACE_TABLE: RefCell<HashMap<usize, Vec<usize>>> = RefCell::new(HashMap::new());
    }
    ```
    这是实现线程隔离的**关键**。`thread_local!` 确保了 `G_THREAD_REPLACE_TABLE` **不是一个全局变量**，而是**每个线程都拥有一份完全独立、互不干扰的副本**。

### 核心执行流程：陷阱、单步调试与上下文魔术 (x86_64 架构)

`mockrs` 的执行流程是一场精妙的底层操作秀。尤其是在处理一个**未被模拟**的线程调用时，它巧妙地利用了 CPU 自身的调试功能，来确保原始指令被安全、原子地执行。

下面是详细的步骤分解：

**第1步：设置钩子 (The Hook)**
*   当 `mock!` 宏首次作用于目标函数 `F` 时，`mockrs` 会执行一次性设置。
*   它首先读取函数 `F` 开头的几字节机器码（即第一条指令），并将其完整地复制到一个被称为“蹦床 (Trampoline)”或“Trunk”的专属可执行内存区域。
*   然后，它将函数 `F` 的第一个字节**全局地**替换为 `0xcc`。这是 `x86_64` 架构上的 `int3` 指令，一条专门用于触发软件断点的陷阱指令。

**第2步：函数调用与陷阱触发**
*   此时，**任何线程**对函数 `F` 的调用，都会立即执行 `int3` 指令。
*   CPU 捕获到这个陷阱，暂停当前执行流，并向操作系统发出一个 `SIGTRAP` 信号。
*   `mockrs` 预先注册的**全局信号处理器** (`handle_trap_signal`) 被内核激活，并接收到当前线程中断时的完整 CPU 上下文（包括所有寄存器的状态）。

**第3步：执行路径分发（核心逻辑）**
*   信号处理器首先查询当前线程的**线程本地存储 (TLS)**，即 `G_THREAD_REPLACE_TABLE`，以确定如何响应。

*   **场景 A：当前线程需要被模拟（简单路径）**
    1.  处理器在 TLS 中找到了为函数 `F` 注册的模拟函数 `M`。
    2.  它直接修改 CPU 上下文中的**指令指针寄存器 (`RIP`)**，使其指向模拟函数 `M` 的地址。
    3.  信号处理器返回。CPU 从新的 `RIP` 地址开始执行，即直接执行了模拟函数 `M`。流程结束。

*   **场景 B：当前线程不需要被模拟（精髓所在）**
    1.  处理器在 TLS 中**未**找到函数 `F` 的模拟记录。它必须执行原始指令。
    2.  **进入单步调试模式**：处理器修改 CPU 上下文中的 `EFLAGS` 寄存器，**设置其陷阱标志位 (Trap Flag, TF)**。这个标志位一旦被设置，CPU 就会进入一种特殊的“单步调试”模式：每成功执行完一条指令，就会自动触发一次 `SIGTRAP`
陷阱。
    3.  **执行原始指令**：处理器将指令指针 (`RIP`) 指向“蹦床”内存区中保存的那条原始指令。
    4.  信号处理器返回。CPU 从“蹦床”中**仅仅执行这一条**被备份的原始指令。
    5.  **再次触发陷阱**：由于陷阱标志位 (TF) 已被设置，这条指令刚一执行完毕，CPU 立刻**再次触发** `SIGTRAP` 信号，第二次进入我们的信号处理器。
    6.  **恢复并返回**：信号处理器第二次被激活。它通过检查 `EFLAGS` 寄存器，发现当前处于单步模式，于是明白这是“执行原始指令后”的返回陷阱。它执行以下恢复操作：
        *   清除 `EFLAGS` 寄存器中的陷阱标志位，**退出单步调试模式**。
        *   计算出原始函数 `F` 中，第一条指令执行完毕后应该继续执行的正确地址（即 `F` 的起始地址 + 原始指令的长度）。
        *   将指令指针 (`RIP`) 设置为这个计算出的返回地址。
    7.  信号处理器返回。CPU 从原始函数 `F` 的第二条指令开始，无缝地继续执行下去。

通过这一套“陷阱 -> 设置调试标志 -> 执行 -> 再陷阱 -> 恢复”的流程，`mockrs` 保证了即使在多线程环境下，对共享函数代码的修改也能够被安全、正确地处理，实现了无懈可击的线程隔离。

### 核心技术栈
*   **`nix`**: 用于处理 POSIX 系统调用。
*   **`lazy_static`**: 用于安全地初始化全局静态数据。
*   **`iced-x86`** (`x86_64`) 和 **`capstone`** (`aarch64`): 用于精确地反汇编和编码机器指令。

---

## 5. 实现效果

`mockrs` 的实现带来了革命性的效果：

*   **通用性**：真正实现了“万物皆可模拟”，为 Rust 测试提供了前所未有的灵活性。
*   **低侵入性**：无需为了可测试性而修改生产代码的设计（如引入不必要的 Trait）。
*   **接口简洁**：`mock!` 宏屏蔽了所有底层复杂性，使用体验极为简单。
*   **并发安全**：精巧的线程隔离设计，让编写并行测试信心十足，无惧状态污染。

`mockrs` 通过深入底层，解决了 Rust 主流模拟方案的固有局限性，并以一种极为优雅的方式攻克了线程隔离的难题，为那些传统方法难以触及的测试场景提供了一个强大而可靠的解决方案。